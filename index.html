<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Just a Minute (JAM) Speaking Challenge</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { margin:0; font-family: 'Segoe UI', sans-serif; display:flex; align-items:center; justify-content:center; height:100vh;
           background: linear-gradient(135deg,#c8f7d6,#a3e9a6); }
    .card { width:520px; background:#f9fff9; border-radius:18px; padding:28px; box-shadow:0 10px 30px rgba(0,0,0,0.12); text-align:center; }
    h2 { margin:0 0 16px; font-size:22px; }
    .topic { font-size:18px; color:#333; margin-bottom:16px; font-weight:500; }
    .timer { font-size:16px; color:#d9534f; margin-bottom:12px; }
    .controls { display:flex; gap:12px; justify-content:center; margin-bottom:12px; }
    button { background:#6ad07a; border:none; padding:10px 18px; border-radius:24px; cursor:pointer; font-weight:600; }
    .secondary { background:#9be8a6; }
    .status { color:#333; margin-top:8px; min-height:2.8em; }
    .small { font-size:13px; color:#666; margin-top:6px; }
    pre { text-align:left; white-space:pre-wrap; word-break:break-word; background:#f1f6f1; padding:10px; border-radius:8px; display:none; }
  </style>
</head>
<body>
  <div class="card">
    <h2>üé§ Just a Minute (JAM) Speaking Challenge</h2>
    <div id="topicBox" class="topic"></div>
    <div id="timerDisplay" class="timer"></div>
    <div class="controls">
      <button id="speakBtn">üéô Speak Now</button>
      <button id="startBtn">üöÄ Start Preparation</button>
      <button id="nextBtn" class="secondary">Next Topic üîÅ</button>
    </div>
    <div id="result" class="status"></div>
    <div class="small">Tip: Open DevTools ‚Üí Network to inspect API requests. Microphone requires HTTPS or localhost.</div>
    <div id="debug" style="display:none"><pre id="debugPre"></pre></div>
  </div>
<script>
/*
 Robust topic loader:
  - Fetches topics from an external API (JSONPlaceholder as mock)
  - Stores a pool in localStorage for offline fallback
  - Falls back to embedded list if API and cache fail
*/
const POOL_KEY = 'jam_topic_pool_v1';
const POOL_SIZE = 8;
const API_URL = 'https://jsonplaceholder.typicode.com/posts'; // Mock API; replace with your endpoint
const fallbackTopics = [
  { topic: "Your favorite hobby", keywords: ["hobby", "favorite", "activity", "enjoy", "pastime", "interest", "fun"] },
  { topic: "Why you love traveling", keywords: ["travel", "journey", "explore", "adventure", "destination", "culture", "trip"] },
  { topic: "The importance of teamwork", keywords: ["team", "teamwork", "collaboration", "group", "cooperation", "together"] }
];
let pool = [];
let currentTopic = null; // { topic: string, keywords: string[] }
let preparationTimer = null;
let recordingTimer = null;
let recordingTimerDisplay = null;
const topicBox = document.getElementById('topicBox');
const timerDisplay = document.getElementById('timerDisplay');
const resultDiv = document.getElementById('result');
const debugPre = document.getElementById('debugPre');
const speakBtn = document.getElementById('speakBtn');
const startBtn = document.getElementById('startBtn');
document.getElementById('nextBtn').addEventListener('click', loadTopic);
startBtn.addEventListener('click', startPreparation);
speakBtn.addEventListener('click', startSpeaking);

init();

async function init() {
  console.log('Initializing...');
  // Load cached topics from localStorage, if available
  const stored = localStorage.getItem(POOL_KEY);
  if (stored) {
    try {
      pool = JSON.parse(stored);
      console.log('Loaded pool from localStorage:', pool.length, 'topics');
    } catch (e) {
      pool = [];
      console.error('Failed to parse stored pool:', e);
    }
  }
  // Fetch fresh topics from API
  await fetchTopics();
  // If pool is still empty, use fallbackTopics
  if (!pool || pool.length < 1) {
    pool = [...fallbackTopics];
    localStorage.setItem(POOL_KEY, JSON.stringify(pool));
    console.log('Initialized pool with fallback topics:', pool.length);
  }
  loadTopic();
}

async function fetchTopics() {
  console.log('Fetching topics from API...');
  try {
    const response = await fetch(API_URL, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        // Uncomment and add API key if required
        // 'Authorization': 'Bearer YOUR_API_KEY'
      },
    });
    if (!response.ok) {
      throw new Error(`API request failed with status ${response.status}`);
    }
    const data = await response.json();
    // Transform JSONPlaceholder data to match { topic, keywords } format
    // JSONPlaceholder returns { id, title, body, userId }
    pool = data.slice(0, POOL_SIZE).map(item => ({
      topic: item.title, // Use post title as topic
      keywords: item.body.split(' ').slice(0, 5).map(word => word.toLowerCase().replace(/[^\w]/g, '')) // Extract first 5 words as keywords
    }));
    // Validate transformed data
    if (!pool.every(item => item.topic && Array.isArray(item.keywords))) {
      throw new Error('Invalid API response format after transformation');
    }
    localStorage.setItem(POOL_KEY, JSON.stringify(pool)); // Cache topics
    console.log('Fetched and cached', pool.length, 'topics from API');
  } catch (err) {
    console.error('fetchTopics error:', err);
    resultDiv.textContent = 'Failed to fetch topics from API. Using cached or fallback topics.';
  }
}

async function loadTopic() {
  console.log('Loading topic...');
  clearTimers();
  resultDiv.textContent = '';
  timerDisplay.textContent = '';
  topicBox.textContent = 'Loading topic...';
  speakBtn.disabled = true;
  startBtn.disabled = true;

  // Ensure pool is populated
  if (pool.length === 0) {
    await fetchTopics(); // Try fetching again
    if (pool.length === 0) {
      pool = [...fallbackTopics]; // Fallback to hardcoded topics
      localStorage.setItem(POOL_KEY, JSON.stringify(pool));
      console.log('Repopulated empty pool with fallback topics:', pool.length);
    }
  }

  try {
    currentTopic = pool[Math.floor(Math.random() * pool.length)];
    console.log('Selected topic:', currentTopic.topic);
    if (topicBox) {
      topicBox.textContent = currentTopic.topic;
    } else {
      console.error('topicBox element not found!');
    }
    startBtn.disabled = false;
    resultDiv.textContent = 'Topic loaded. Click Start Preparation to begin.';
  } catch (err) {
    console.error('loadTopic error:', err);
    topicBox.textContent = 'Error loading topic.';
    resultDiv.textContent = 'Failed to load topic. Click Next Topic to retry.';
  }
}

function startPreparation() {
  if (!currentTopic) {
    resultDiv.textContent = 'No topic loaded. Click Next Topic.';
    return;
  }
  clearTimers();
  let timeLeft = 60; // 1 minute preparation
  timerDisplay.textContent = `Preparation Time: ${timeLeft} seconds`;
  startBtn.disabled = true;
  speakBtn.disabled = false;
  preparationTimer = setInterval(() => {
    timeLeft--;
    timerDisplay.textContent = `Preparation Time: ${timeLeft} seconds`;
    if (timeLeft <= 0) {
      clearInterval(preparationTimer);
      timerDisplay.textContent = '';
      resultDiv.textContent = 'Preparation time over. Click Speak Now to talk for 1 minute.';
    }
  }, 1000);
  resultDiv.textContent = 'Prepare your thoughts for 1 minute!';
}

function startSpeaking() {
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SpeechRecognition) {
    alert('Speech Recognition not supported. Use Chrome/Edge on desktop.');
    resultDiv.textContent = 'Speech Recognition not supported. Use Chrome/Edge on desktop.';
    return;
  }
  if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
    console.warn('Not secure origin ‚Äî microphone permissions may be blocked.');
    resultDiv.textContent = 'Note: For consistent microphone access use HTTPS or localhost.';
    return;
  }
  clearTimers();
  window.speechSynthesis.cancel();
  resultDiv.textContent = 'Speaking‚Ä¶ Talk about the topic for 1 minute.';
  timerDisplay.textContent = 'Speaking Time: 60 seconds';
  let timeLeft = 60;
  const recognition = new SpeechRecognition();
  recognition.lang = 'en-US';
  recognition.interimResults = false;
  recognition.maxAlternatives = 1;
  recognition.start();
  recordingTimer = setTimeout(() => {
    recognition.stop();
    timerDisplay.textContent = '';
    resultDiv.textContent = 'Recording stopped. Analyzing‚Ä¶';
  }, 60000);
  recognition.onresult = function (event) {
    clearTimeout(recordingTimer);
    timerDisplay.textContent = '';
    const spoken = event.results[0][0].transcript;
    analyzeSpeech(spoken);
  };
  recognition.onerror = function (ev) {
    clearTimeout(recordingTimer);
    timerDisplay.textContent = '';
    console.error('Speech recognition error', ev);
    resultDiv.textContent = 'Speech recognition error: ' + (ev.error || 'unknown');
  };
  recognition.onend = function () {
    clearTimeout(recordingTimer);
    if (resultDiv.textContent === 'Speaking‚Ä¶ Talk about the topic for 1 minute.') {
      resultDiv.textContent = 'Recording stopped. Click Speak Now to try again.';
    }
  };
  recordingTimerDisplay = setInterval(() => {
    timeLeft--;
    timerDisplay.textContent = `Speaking Time: ${timeLeft} seconds`;
    if (timeLeft <= 0) {
      clearInterval(recordingTimerDisplay);
    }
  }, 1000);
}

function analyzeSpeech(userSpeech) {
  if (!currentTopic) {
    resultDiv.textContent = 'No topic to analyze. Click Next Topic.';
    return;
  }
  const spoken = normalize(userSpeech || '');
  const relevance = topicRelevanceScore(spoken, currentTopic.keywords);
  resultDiv.innerHTML = `<b>You said:</b> ${escapeHtml(userSpeech)}<br><b>Topic Relevance:</b> ${relevance.toFixed(1)}%`;
}

function normalize(s) {
  return s.toLowerCase().replace(/[^\w\s']/g, '').replace(/\s+/g, ' ').trim();
}

function topicRelevanceScore(spoken, keywords) {
  const words = spoken.split(' ').filter(Boolean);
  if (words.length === 0) return 0;
  let matches = 0;
  const keywordSet = new Set(keywords.map(k => k.toLowerCase()));
  words.forEach(w => { if (keywordSet.has(w)) matches++; });
  return (matches / words.length) * 100;
}

function clearTimers() {
  if (preparationTimer) clearInterval(preparationTimer);
  if (recordingTimer) clearTimeout(recordingTimer);
  if (recordingTimerDisplay) clearInterval(recordingTimerDisplay);
}

function logDebug(msg) {
  debugPre.textContent += msg + '\n';
  console.log(msg); // Log to console for debugging
}

function escapeHtml(str) {
  if (!str) return '';
  return str.replace(/[&<>"']/g, s => ({
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  }[s]));
}
</script>
</body>
</html>
